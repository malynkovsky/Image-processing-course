## Работа 1. Исследование гамма-коррекции
автор: Малынковский О.В.
дата: @time_stemp@

<!-- url: https://gitlab.com/malynkovsky/image_proc/-/tree/master/lab01 -->

### Задание
1. Сгенерировать серое тестовое изображение в виде прямоугольника размером 768х60 пикселя с плавным изменение пикселей от черного к белому, одна градация серого занимает 3 пикселя по горизонтали.
2. Применить  к изображению гамма-коррекцию с коэффициентом из интервала 2.2-2.4 и получить изображение.
3. Сгенерировать серое тестовое изображение в виде прямоугольника размером 768х60 пикселя со ступенчатым изменением яркости от черного к белому (от уровня 5 с шагом 10), одна градация серого занимает 30 пикселя по горизонтали.
4. Применить  к изображению гамма-коррекцию с коэффициентом из интервала 2.2-2.4 и получить изображение.
5. Показать визуализацию результатов в виде одного изображения

### Результаты

![](lab01.png)
Рис. 1. Результаты работы программы (сверху вниз $I_1$, $G_1$, $I_2$, $G_2$)

### Текст программы

```cpp
#include <opencv2/opencv.hpp>

using namespace cv;

int main()
{
	int height = 60, width = 768;
	Mat result_image(Mat::zeros(height * 2, width, CV_8UC1));//результирующее изображение
	//cоздаём картинку (одноканальную, глубина 8 бит), все пискели инициализируем ноликами
	Mat img(Mat::zeros(height, width, CV_8UC1));
	//заполняем значениями так, чтобы получился градиент от черного к белому (делим на 3 из-за размера картинки)
	for (int col = 0; col < width; col += 1) {
		for (int row = 0; row < height; row += 1) {
			img.at<uchar>(Point(col, row)) = col / 3;
		}
	}
	//копируем градиент в верхнюю часть результирующего изображения, а с этим проделаем гамма-коррекцию с коэффициентом 2.4
	img.copyTo(result_image(Rect(0, 0, width, height)));
	img.convertTo(img, CV_64FC1, 1.0 / 255);//переход к float, 1/255 означает, что каждое значение будет поделено на 255
	cv::pow(img, 2.4, img);//возведение в степень значений в каждом пикселе
	img.convertTo(img, CV_8UC1, 255);//возвращение к исходному типу данных
	//копируем скорректированное изображение в нижнюю часть результирующего изображения
	img.copyTo(result_image(Rect(0, height, width, height)));
	//выводим результат
	namedWindow("Gradient and gamma-corrected gradient - 1", 1);
	imshow("Gradient and gamma-corrected gradient - 1", result_image);




	Mat result_image2(Mat::zeros(height * 2, width, CV_8UC1));//результирующее изображение
	//cоздаём картинку (одноканальную, глубина 8 бит), все пискели инициализируем ноликами
	Mat img2(Mat::zeros(height, width, CV_8UC1));
	//заполняем значениями так, чтобы получился ступенчатый переход от черного к белому (от 5 с шагом десять)
	for (int col = 0; col < width; col += 1) {
		for (int row = 0; row < height; row += 1) {
			img2.at<uchar>(Point(col, row)) = 5 + col / 30 * 10;
		}
	}
	//копируем градиент в верхнюю часть результирующего изображения, а с этим проделаем гамма-коррекцию с коэффициентом 2.4
	img2.copyTo(result_image2(Rect(0, 0, width, height)));
	img2.convertTo(img2, CV_64FC1, 1.0 / 255);//переход к float, 1/255 означает, что каждое значение будет поделено на 255
	cv::pow(img2, 2.4, img2);//возведение в степень значений в каждом пикселе
	img2.convertTo(img2, CV_8UC1, 255);//возвращение к исходному типу данных
	//копируем скорректированное изображение в нижнюю часть результирующего изображения
	img2.copyTo(result_image2(Rect(0, height, width, height)));
	//выводим результат
	namedWindow("Gradient and gamma-corrected gradient - 2", 1);
	imshow("Gradient and gamma-corrected gradient - 2", result_image2);


	Mat save_arr[2] = { result_image, result_image2 };
	Mat save;
	vconcat(save_arr, 2, save);
	imwrite("lab01.png", save);
	waitKey(0);
	return 0;
}

```